## 01 why learn

1. 建立时间、空间复杂度意识。
2. 写出高质量的代码、提升编程技能。
3. 能够设计基础架构、训练逻辑思维。

## 02 how learn 

### 十种数据结构

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树

### 十种算法

递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

### 学习技巧

1. 边学边练，适度刷题（三分学七分练）。
2. 多问、多思考、多互动。
3. 打怪升级学习法。
4. 知识是慢慢沉淀，不可能一下子掌握所有。

## 03/4 复杂度分析

### 时间复杂度

大O时间复杂度表示执行时间随数据规模增长的变化趋势（执行效率），也叫渐进时间复杂度。当n很大时，公式中的低阶、常量、系数并不左右增长趋势，可忽略。

#### 分析方法

1. 只关注循环执行次数最多的一段代码。
2. 多段代码，总复杂度等于量级最大的那段代码的复杂度。
3. 嵌套代码，总复杂度等于嵌套内外代码复杂度的乘积。

#### 最好时间复杂度

#### 最坏时间复杂度

#### 平均时间复杂度

#### 均摊时间复杂度

```
function find(array, x) {
	for(let i = 0, len = array.len; i < len; ++i) {
		if(array[i] === x) return i;
	}
	return -1;
}
最好时间复杂度 O(1)
最坏时间复杂度 O(n)
平均时间复杂度 
	x在array中的概率是1/2，x在数组的第i项的概率是1/n
	1*1/2n + 2*1/2n + ... + n*1/2n + n*1/2 = (n+3)/4
均摊时间复杂度 （摊还分析法）
	对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，个别情况下时间复杂度很高，就可以分析看能否将较高时间复杂度分摊到其他的较低时间复杂度上。这种情况一般较少，如果出现一般均摊时间复杂度等于最好时间复杂度。
```



### 复杂度量级

- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n2)、立方阶 O(n3)、...、K方阶 O(nk)   （以上均为多项式量级）
- 指数阶 O(2n)   （非多项式量级）
- 阶乘阶 O(n!)    （非多项式量级）

随着数据规模n的增大，非多项式量级算法的执行事件会急剧增加。 

```
示例1: 时间复杂度O(logn)
    i = 1;
    while (i < n) {
        i = i * 2;  // i = i * 3; 时间复杂度一样
    }
    以2、3、...、10为低的时间复杂度都是O(logn)
示例2：时间复杂度O(m+n)
function sum(m, n) {
	let sum1 = 0;
	for(let i = 1; i < m; ++i) {
		sum1 += i;
	}
	let sum2 = 0;
	for(let j = 1; j < n; ++j) {
		sum2 += j;
	}
	return sum1 + sum2;
}
```

### 空间复杂度

空间复杂度表示算法的存储空间于数据规模之间的增长关系。

常见的空间复杂度 O(1)、O(n)、O(n2)。

## 05 数组

数组用一块连续的内存空间，来存储相同类型的一组数据，是一种线性的数据结构。

- 线性表：数据线性排列，只有前后关系。数组、链表、栈、队列都是线性表结构。
- 非线性表：数据间不止简单的前后关系。二叉树、堆、图都是非线性表结构。

最大的特点：支持使用下标的随机访问，但插入、删除操作比较低效（平均情况时间复杂度为O(n)）。

### 查询

连续的内存空间、相同数据类型 >>>  随机访问。

内存地址计算公式：a[i]_address = base_address + i * data_type_size。

数组访问越界问题，C语言中可能会bug，其他语言会做越界检测或undefined。

### 插入和删除

1. 一般，插入/删除第k个位置，k~n的元素需要顺序后/前挪一位。

2. 特殊

   插入：数组只作为容器，不关注顺序，插入操作可将第k位的数据挪到最后，新元素插入到第k位。

   删除：删除多个数据时，每次删除操作只是标记数据已经被删除，当数组没有空间存储数据时才触发一次真正的删除操作。

### 容器 vs 数组

容器，如Java中的ArrayList，对数组操作细节封装，支持动态扩容。业务开发使用容器，架构使用数组。

## 06/7 链表

通过"指针"将一组零散的内存块串联起来使用，每个链表的结点由数据和记录下一个结点地址的后继指针next组成。

### 单链表

→ data next → data next → data next → data next → null

插入和删除操作的时间复杂度是O(1)。

实际开发中，从链表中删除数据的情况：

- 情况一：删除节点中 "值等于某个给定值"的结点。遍历查找目标结点O(n) + 删除操作O(1)。
- 情况二：删除给定指针指向的节点。遍历查找前驱结点O(n) + 删除操作O(1)。

### 循环链表

### 双向链表

需要额外的空间来存储前驱结点的地址，结点多了一个记录上一个结点地址的prev指针。

双向链表，对上述情况二的链表删除操作，时间负责度O(1)。

### 数组 vs 链表

数组大小固定。

链表自动扩容，但指针消耗额外的存储空间。对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片（如Java中会导致频繁的GC）。

### 实现LRU缓存算法

1. 维护一个有序的单向链表；
2. 新的数据访问，先遍历查询链表；
3. 查到了，将其从原来的位置删除，插入到链表的头部；
4. 没查到，如果缓存未满，将此结点插入到链表的头部；如果缓存满了，删除尾结点，再插入新的数据结点。

### 链表代码技巧

#### （1）理解指针或引用的含义

将某个变量赋值给指针，就只将这个变量的地址赋值给（告诉给）指针。指针中存储了这个变量的地址，指向这个变量。p->next = q，p结点的next指针存储了q结点的内存地址。

#### （2）警惕指针丢失和内存泄露

```
在a、b结点之间插入x结点
p->next=x; x->next = p->next;  ✖
x->next = p->next; p->next=x;  ✔

```

#### （3）利用哨兵简化边界问题处理

```
插入要考虑的边界问题：
if(head == null) {
	head = new_node;
}
删除要考虑的边界问题：
if(head->next == null) {
	head = null;
}
```

哨兵结点，不存储数据，head指针指向哨兵结点。带有哨兵结点的链表叫带头链表。

#### （4）重点关注边界条件处理

写完代码检查一下几种情况，代码能否正常运行：

1. 链表为空，正常运行否？
2. 链表只包含一个节点，正常运行否？
3. 链表只包含两个结点，正常运行否？
4. 处理头结点和尾节点的时候，正常运行否？

#### （5）画图辅助思考

#### （6）多写多练

重点问题：

1. 单链表反转
2. 链表中环的检测
3. 两个有序链表合并
4. 删除链表倒数第n个结点
5. 求链表的中间结点

## 08 栈

先进后出，后进先出的数据结构。是一种"操作受限"的线性表，只能在一端插入和删除数据。

用数组实现的栈，叫顺序栈。用链表实现的栈，叫链式栈。

出栈、入栈操作的时间复杂度、空间复杂度都是O(1)。

支持动态扩容的顺序栈，入栈的均摊时间复杂度是O(1)。

### 在函数调用中的应用

函数调用栈。操作系统分配给线程一块独立的内存空间，这块内存被组织成"栈"结构，用来存储函数调用时的临时变量。函数执行临时变量入栈，执行完毕出栈。

### 在表达式求值中的应用

编译器处理算术表达式，就是通过两个栈来实现的。一个保存操作数的栈，一个保存运算符的栈。

从左向右遍历，遇到数字入栈，遇到运算符则与运算符栈顶元素比较，优先级高入栈，优先级低或相同，则先取栈顶运算符和两个操作数，将运算结果压入操作数栈。栈清空就得到了最后的计算结果。

### 内存中的堆栈

内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。

内存空间在逻辑上分为三部分：代码区、静态数据区、动态数据区。

- 代码区：存放方法体的二进制代码。

- 静态数据区：存储全局变量、静态变量、常量。系统自动分配和回收。
- 栈区：存储运行方法的形参、局部变量、返回值。系统自动分配和回收。
- 堆区：对象存储。

## 09 队列

先进者先出。基本操作：入队enqueue()、出队dequeue()。是一种"操作受限"的线性表。

用数组实现的栈，叫顺序队列。用链表实现的栈，叫链式队列。

队列需要两个指针，一个是head指针 指向队头，一个是tail指针 指向队尾。

### 循环队列

首尾连成环，这样只要队列中有空位，就可以继续入队。

队空判断：head === tail。 队满判断，（tail + 1) % n === head 或 记录队列的size（=== n则满）。

### 阻塞队列

当队列为空时，从队头取数据会被阻塞；当队满时，插入数据会被阻塞，直到队列有空闲位置在插入数据。类似于生产者-消费者模式。

### 并发队列

线程安全的队列叫做并发队列。enqueue()、dequeue()方法上加锁。

数组循环队列+CAS原子操作，可实现高效的并发队列。

## 10 递归

### 递归需要满足的条件

1. 一个问题的解可以分解为几个子问题的解。
2. 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件。

### 编写递归代码

1. 找到递推公式。
2. 推敲递归终止条件。

注意，不要纠结与递归细节，不要想一层层的调用关系。

### 递归代码问题

#### 堆栈溢出

可以通过限制递归深度的方法处理。但递归深度限制与当前线程剩余的栈空间大小有关，不容易确定。

#### 重复计算

避免重复计算，可以使用散列表（如map）来保存已经求解过的f(k)。

### 迭代

所有可以使用递归的都可以使用迭代实现。

递归是借助栈来实现的。迭代则是手动模拟入栈、出栈过程。

## 11/12/13/14 排序

排序算法的稳定性

实际开发中，排序的不一定是单纯的整数，可能是一组对象，按某个key排序。如 订单交易系统，按金额从小到大排序，相同金额按下单先后排序，就需要使用稳定排序算法。

### 冒泡排序

比较相邻两元素大小关系，每一次冒泡一个元素归位，重复n次完成n个数据的排序工作。

稳定排序算法。时间复杂度 平均、最坏O(n2)，最好O(n)。空间复杂度O(1)。

### 插入排序

将 未排序区间的元素 正确的插入 已排序区间。

稳定排序算法。时间复杂度 平均、最坏O(n2)，最好O(n)。空间复杂度O(1)。

```
冒泡排序，交换数据 需要3个赋值操作。
插入排序，插入后移 需要1个赋值操作。 ✔更受欢迎 
```

### 选择排序

每次从 未排序区间 找到最小的元素，放到（通过交换的方式） 已排序区间的最后。

不稳定排序算法。时间复杂度O(n2)。空间复杂度O(1)。

### 归并排序

分治思想。稳定排序算法。时间复杂度 O(nlogn)。空间复杂度O(n)。

- 递推公式：merge_sort(p, r) = merge_sort(p, q) , merge_sort(q+1, r)

- 终止条件：p >= r

### 快速排序

分区思想。不稳定排序算法。时间复杂度 最好、平均O(nlogn)，最坏O(n2)。空间复杂度O(1)。

### 桶排序

将要排序的数据分到几个有序的桶里，每个桶内在单独使用归并或快排进行排序。

```
n个数据，m个桶，每个桶有k=n/m个元素。
1个桶 排序时间复杂度O(klogk)。
m个桶 排序时间复杂度O(m*k*logk) = O(n*log(n/m))。
当m接近n时，log(n/m)为常数，时间复杂度接近O(n)。
```

桶排序要求，排序数据分布均匀。适用于外部排序，即数据量大，内存有限。

### 计数排序

数据最大值为k，最小值为0。把数据分为k个桶，每个桶内数值相同。

计数排序要求，数据范围k小，排序数据必须是非负数（或者可以转化为非负数）。

### 基数排序

如手机号码排序，先按最后一位排序手机号（借助桶排序或计数排序），然后倒数第二位，以此类推，最后按第一位重新排序。k位，时间复杂度O(k*n)。

基数排序要求，数据可按位分割，位之间有递进关系。

### 排序优化

快速排序分区点选择：三数取中法、随机法。

C语言中，qsort 个数小于4使用插入排序，几KB使用归并排序，MB使用快速排序（手动模拟递归解决堆栈溢出问题）。

## 15/16 二分查找

二分思想，每次与区间的中间数据比对大小，缩小查找区间的范围。

时间复杂度：查找区间变化 n/(2k)，k最大为logn。

```
循环终止条件： high <= low
mid取值： low+(100-50>>1)
low和high的更新： low = mid + 1 或 high = mid - 1
```

应用场景：

- 数组结构，要求内存空间连续。
- 有序数据，如果没有序需要先排序。
- 静态数据集合，一次排序多次查找。
- 不适合数据量太小（直接顺序遍历），不适合数据量太大（没有那么多连续内存空间）

二分查找变形：

- 查找第一个值等于给定值的元素。
- 查找最后一个值等于给定值的元素。
- 查找第一个大于等于给定值的元素。
- 查找最后一个小于等于给定值的元素。

二分查找能解决的问题，用散列表或二叉树也可实现。值等于给定值 倾向于使用散列表或二叉树，上述变体问题 需要使用二分查找。

## 17 跳表

建立索引。

```
第一级索引：一个单链表。
第二级索引：在一级之上，每两个（3/5）节点抽出一个结点放到第二级索引。
第三级缩影：在二级之上，...
...
```

查找、插入、删除时间复杂度：O(logn)。空间复杂度O(n)。

## 18/19/20 散列表

### 散列思想

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。

通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。

用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

### 散列函数

把它定义成hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。

散列函数不能过于复杂，生成的值要尽可能随机且均匀分布。

散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法。

### 散列冲突

散列冲突解决的两种方法，开发寻找和链表法。

#### 开放寻址法

- 线性探测法：出现了散列冲突，我们就重新探测一个空闲位置，将其插入。
- 二次探测法：探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+4...
- 双重散列：使用一组散列函数hash1(key)，hash2(key)，hash3(key)..

- 优点：数据都存储在数组中，可有效利用CPU缓存加快查询速度。序列化更简单。
- 缺点：删除数据需要特殊标记。散列冲突代价更高。装载因子不能太大，导致更浪费内存空间。

#### 链表法

每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。插入的时间复杂度是O(1)。查找或删除时间复杂度跟链表的长度k成正比。

- 优点：可承受更高的装载因子
- 缺点：需要额外的内存用于链表指针的存放。链表节点分散不利于CPU缓存进而影响执行效率。

在链表长度超过阈值时，修改数据结构为跳表或红黑树，这样极端情况下查找时间只是O(logn)

### 动态扩容

当装载因子过大时，重新申请一个更大的散列表，将数据搬移到新散列表中。

避免低效扩容：原散列表较大时，装载因子达到阈值，只新申请空间，新数据插入到新散列表，并从老散列表取一个数据放到新散列表。一点一点搬移。

### 工业级散列表

如 Java的HashMap。 初始大小，默认值16；装载因子，默认值0.75；散列冲突解决办法，升级链表（链表长度>8转换为红黑树）。

## 40 动态规划

### 背包问题

```js
// 回溯算法
let maxW = 0;
let weights = [2,2,4,6,3];
let n = 5;
let w = 9;
let cache = {};
function f(i, cw) {
	if(cw === w || i === n) {
		if(cw > maxW) {
			maxW = cw;
			return;
		}
	}
	if(cache[i] === cw) return;
	cache[i] = cw;
	f(i + 1, cw);
	if( cw + weights[i] <= w) {
		f(i + 1, cw + weight[i])
	}
}

// 动态规划
function knapsack(weight, n, w) {
	let cache = {};
	let cache['0'] = 0;
	for(let i = 1; i < n; i++) {
		for(let j = 0; j <= w; j++) {
			if(cache[i-1] === j) {
				cache[i] === j;
			}
		}
		for(let j = 0; j <= w - weight[i]; j++) {
			if(cache[i-1] === j) {
				cache[i] = j + weight[i];
			}
		}
	}
	return cache[n];
}
// 动态规划 优化
function knapsack(items, n, w) {
	let states = [];
	states[0] = true;
	states[item[0]] = true;
	for(let i = 1; i < n; i++) {
		for(let j = w - items[i]; j >= 0; j--) {
			if(states[j]) {
				states[j+items[i]] = true;
			}
		}
	}
	for(let i = w; i >= 0; i--) {
		if(states[i]) return i;
	}
}

// 背包物品最大价值
function knapsack(weight, value, n, w) {
	let states = new Array(n).fill(new Array(w+1).fill(-1));
	states[0][0] = 0;
	states[0][weight[0]] = value[0];
	for(let i = 1; i < n; i++) {
		for(let j = 0; j <= w; j++) {
			if(states[i-1][j] >= 0) {
				states[i][j] = states[i-1][j]
			}
		}
		for(let j = 0; j <= w - weight[i]; j++) {
			if(states[i-1][j] >= 0) {
				let v = states[i-1][j] + value[i];
				if(v > states[i][j+weight[i]]) {
					states[i][j+weight[i]] = v;
				}
			}
		}
	}
	let max = -1;
	for(let j = 0; j <= w; j++) {
		if(states[n-1][j] > max) {
			max = states[n-1][j]
		}
	}
	return max;
}

// 双十一凑单
function double11Advance(items, n, w) {
	let states = new Array(n).fill([]);
	states[0,0] = true;
	states[i][items[0]] = true;
	for(let i = 1; i < n; i++) {
		for(let j = 0; j <= 3*w; j++) {
			if(states[i-1][j]) {
				states[i][j] = states[i-1][j];
			}
		}
		for(let j = 0; j <= 3*w - items[i]; j++) {
			if(states[i-1][j]) {
				states[i][j+items[i]] = true;
			}
		}
	}
	let j;
	for(j = w; j < 3*w + 1; j++) {
		if(states[n-1][j]) {
			break;
		}
	}
	for(let i = n -1; i >= 1; i--) {
		if(j - items[i] >= 0 && states[i-1][j-items[i]]) {
			console.log(items[i] + ' '); // 购买这个商品
			j = j - items[i];
		}
	}
	if(j != 0) {
		console.log(items[0]);
	}
}
```



动态规划：重叠子问题、状态转移方程