## 01 why learn

1. 建立时间、空间复杂度意识。
2. 写出高质量的代码、提升编程技能。
3. 能够设计基础架构、训练逻辑思维。

## 02 how learn 

### 十种数据结构

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树

### 十种算法

递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

### 学习技巧

1. 边学边练，适度刷题（三分学七分练）。
2. 多问、多思考、多互动。
3. 打怪升级学习法。
4. 知识是慢慢沉淀，不可能一下子掌握所有。

## 03/4 复杂度分析

### 时间复杂度

大O时间复杂度表示执行时间随数据规模增长的变化趋势（执行效率），也叫渐进时间复杂度。当n很大时，公式中的低阶、常量、系数并不左右增长趋势，可忽略。

#### 分析方法

1. 只关注循环执行次数最多的一段代码。
2. 多段代码，总复杂度等于量级最大的那段代码的复杂度。
3. 嵌套代码，总复杂度等于嵌套内外代码复杂度的乘积。

#### 最好时间复杂度

#### 最坏时间复杂度

#### 平均时间复杂度

#### 均摊时间复杂度

```
function find(array, x) {
	for(let i = 0, len = array.len; i < len; ++i) {
		if(array[i] === x) return i;
	}
	return -1;
}
最好时间复杂度 O(1)
最坏时间复杂度 O(n)
平均时间复杂度 
	x在array中的概率是1/2，x在数组的第i项的概率是1/n
	1*1/2n + 2*1/2n + ... + n*1/2n + n*1/2 = (n+3)/4
均摊时间复杂度 （摊还分析法）
	对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，个别情况下时间复杂度很高，就可以分析看能否将较高时间复杂度分摊到其他的较低时间复杂度上。这种情况一般较少，如果出现一般均摊时间复杂度等于最好时间复杂度。
```



### 复杂度量级

- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n2)、立方阶 O(n3)、...、K方阶 O(nk)   （以上均为多项式量级）
- 指数阶 O(2n)   （非多项式量级）
- 阶乘阶 O(n!)    （非多项式量级）

随着数据规模n的增大，非多项式量级算法的执行事件会急剧增加。 

```
示例1: 时间复杂度O(logn)
    i = 1;
    while (i < n) {
        i = i * 2;  // i = i * 3; 时间复杂度一样
    }
    以2、3、...、10为低的时间复杂度都是O(logn)
示例2：时间复杂度O(m+n)
function sum(m, n) {
	let sum1 = 0;
	for(let i = 1; i < m; ++i) {
		sum1 += i;
	}
	let sum2 = 0;
	for(let j = 1; j < n; ++j) {
		sum2 += j;
	}
	return sum1 + sum2;
}
```

### 空间复杂度

空间复杂度表示算法的存储空间于数据规模之间的增长关系。

常见的空间复杂度 O(1)、O(n)、O(n2)。

## 05 数组

数组用一块连续的内存空间，来存储相同类型的一组数据，是一种线性的数据结构。

- 线性表：数据线性排列，只有前后关系。数组、链表、栈、队列都是线性表结构。
- 非线性表：数据间不止简单的前后关系。二叉树、堆、图都是非线性表结构。

最大的特点：支持使用下标的随机访问，但插入、删除操作比较低效（平均情况时间复杂度为O(n)）。

### 查询

连续的内存空间、相同数据类型 >>>  随机访问。

内存地址计算公式：a[i]_address = base_address + i * data_type_size。

数组访问越界问题，C语言中可能会bug，其他语言会做越界检测或undefined。

### 插入和删除

1. 一般，插入/删除第k个位置，k~n的元素需要顺序后/前挪一位。

2. 特殊

   插入：数组只作为容器，不关注顺序，插入操作可将第k位的数据挪到最后，新元素插入到第k位。

   删除：删除多个数据时，每次删除操作只是标记数据已经被删除，当数组没有空间存储数据时才触发一次真正的删除操作。

### 容器 vs 数组

容器，如Java中的ArrayList，对数组操作细节封装，支持动态扩容。业务开发使用容器，架构使用数组。

## 06/7 链表

通过"指针"将一组零散的内存块串联起来使用，每个链表的结点由数据和记录下一个结点地址的后继指针next组成。

### 单链表

→ data next → data next → data next → data next → null

插入和删除操作的时间复杂度是O(1)。

实际开发中，从链表中删除数据的情况：

- 情况一：删除节点中 "值等于某个给定值"的结点。遍历查找目标结点O(n) + 删除操作O(1)。
- 情况二：删除给定指针指向的节点。遍历查找前驱结点O(n) + 删除操作O(1)。

### 循环链表

### 双向链表

需要额外的空间来存储前驱结点的地址，结点多了一个记录上一个结点地址的prev指针。

双向链表，对上述情况二的链表删除操作，时间负责度O(1)。

### 数组 vs 链表

数组大小固定。

链表自动扩容，但指针消耗额外的存储空间。对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片（如Java中会导致频繁的GC）。

### 实现LRU缓存算法

1. 维护一个有序的单向链表；
2. 新的数据访问，先遍历查询链表；
3. 查到了，将其从原来的位置删除，插入到链表的头部；
4. 没查到，如果缓存未满，将此结点插入到链表的头部；如果缓存满了，删除尾结点，再插入新的数据结点。

### 链表代码技巧

#### （1）理解指针或引用的含义

将某个变量赋值给指针，就只将这个变量的地址赋值给（告诉给）指针。指针中存储了这个变量的地址，指向这个变量。p->next = q，p结点的next指针存储了q结点的内存地址。

#### （2）警惕指针丢失和内存泄露

```
在a、b结点之间插入x结点
p->next=x; x->next = p->next;  ✖
x->next = p->next; p->next=x;  ✔

```

#### （3）利用哨兵简化边界问题处理

```
插入要考虑的边界问题：
if(head == null) {
	head = new_node;
}
删除要考虑的边界问题：
if(head->next == null) {
	head = null;
}
```

哨兵结点，不存储数据，head指针指向哨兵结点。带有哨兵结点的链表叫带头链表。

#### （4）重点关注边界条件处理

写完代码检查一下几种情况，代码能否正常运行：

1. 链表为空，正常运行否？
2. 链表只包含一个节点，正常运行否？
3. 链表只包含两个结点，正常运行否？
4. 处理头结点和尾节点的时候，正常运行否？

#### （5）画图辅助思考

#### （6）多写多练

重点问题：

1. 单链表反转
2. 链表中环的检测
3. 两个有序链表合并
4. 删除链表倒数第n个结点
5. 求链表的中间结点

## 08 栈

先进后出，后进先出的数据结构。是一种"操作受限"的线性表，只能在一端插入和删除数据。

用数组实现的栈，叫顺序栈。用链表实现的栈，叫链式栈。

出栈、入栈操作的时间复杂度、空间复杂度都是O(1)。

支持动态扩容的顺序栈，入栈的均摊时间复杂度是O(1)。

### 在函数调用中的应用

函数调用栈。操作系统分配给线程一块独立的内存空间，这块内存被组织成"栈"结构，用来存储函数调用时的临时变量。函数执行临时变量入栈，执行完毕出栈。

### 在表达式求值中的应用

编译器处理算术表达式，就是通过两个栈来实现的。一个保存操作数的栈，一个保存运算符的栈。

从左向右遍历，遇到数字入栈，遇到运算符则与运算符栈顶元素比较，优先级高入栈，优先级低或相同，则先取栈顶运算符和两个操作数，将运算结果压入操作数栈。栈清空就得到了最后的计算结果。

### 内存中的堆栈

内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。

内存空间在逻辑上分为三部分：代码区、静态数据区、动态数据区。

- 代码区：存放方法体的二进制代码。

- 静态数据区：存储全局变量、静态变量、常量。系统自动分配和回收。
- 栈区：存储运行方法的形参、局部变量、返回值。系统自动分配和回收。
- 堆区：对象存储。

## 09 队列

先进者先出。基本操作：入队enqueue()、出队dequeue()。是一种"操作受限"的线性表。

用数组实现的栈，叫顺序队列。用链表实现的栈，叫链式队列。

队列需要两个指针，一个是head指针 指向队头，一个是tail指针 指向队尾。

### 循环队列

首尾连成环，这样只要队列中有空位，就可以继续入队。

队空判断：head === tail。 队满判断，（tail + 1) % n === head 或 记录队列的size（=== n则满）。

### 阻塞队列

当队列为空时，从队头取数据会被阻塞；当队满时，插入数据会被阻塞，直到队列有空闲位置在插入数据。类似于生产者-消费者模式。

### 并发队列

线程安全的队列叫做并发队列。enqueue()、dequeue()方法上加锁。

数组循环队列+CAS原子操作，可实现高效的并发队列。

## 10 递归

### 递归需要满足的条件

1. 一个问题的解可以分解为几个子问题的解。
2. 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件。

### 编写递归代码

1. 找到递推公式。
2. 推敲递归终止条件。

注意，不要纠结与递归细节，不要想一层层的调用关系。

### 递归代码问题

#### 堆栈溢出

可以通过限制递归深度的方法处理。但递归深度限制与当前线程剩余的栈空间大小有关，不容易确定。

#### 重复计算

避免重复计算，可以使用散列表（如map）来保存已经求解过的f(k)。

### 迭代

所有可以使用递归的都可以使用迭代实现。

递归是借助栈来实现的。迭代则是手动模拟入栈、出栈过程。